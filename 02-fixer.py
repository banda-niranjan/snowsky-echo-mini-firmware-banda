#!/usr/bin/env python3
"""
ARM Cortex-M Firmware Byte Swap Fixer
This tool repairs firmware images with 16-bit byte-swapped code sections.
Common in Rockchip RKnano series and other ARM Cortex-M implementations.
"""

import struct
import os
import sys

"""
# HIFIEC10 Firmware Reverse Engineering Guide

## 1. Core File Information
* **Target File**: `HIFIEC10_Fixed.bin` (Final product generated by this script)
* **Architecture**: ARM Cortex-M (Rockchip RKnano series)
* **Byte Order**: **Little-endian** (Physical layer de-obfuscation complete, no additional swapping needed)
* **Loading Base Address**: `0x00000000`
* **File Mapping**: 1:1 Flat Mapping (Memory address = File offset)

## 2. Key Memory Layout
| Physical Offset (Hex) | Region Name | Description |
| :--- | :--- | :--- |
| `0x000000` - `0x000460` | Boot Header | Contains SDK version ("RKnano SDK 1.0") and date information, not executable. |
| `0x000460` - `0x0004A0` | Vector Table | **Interrupt Vector Table**. Starting point for analysis. |
| `0x0004A0` - `End` | .text / .data | **Code and Data Region**. Previously obfuscated with 16-bit swapping, now fixed to standard Thumb instructions. |

## 3. IDA Pro / Ghidra Loading Instructions
1.  **Load File**: Select `HIFIEC10_Fixed.bin`.
2.  **Processor Selection**: Choose **ARM** (Little-endian).
3.  **Processor Options**: Enable **Thumb** mode (Cortex-M typically runs Thumb code only).
4.  **Memory Settings**: Set ROM Start / Loading Address to `0x0`.
5.  **Confirm Entry Point**:
    * Jump to offset `0x464` (Reset Vector storage location).
    * Read the value (should be `0x000012ED`).
    * Jump to address `0x12EC` (value minus 1, Thumb flag bit).
    * **Verification**: Instruction should be `CMP R3, #33` (machine code `21 2B`). If correct, loading is accurate.

## 4. Recommended Analysis Path
* **Step 1 (Rebuild Control Flow)**: Start at `0x12EC` (Reset_Handler), press `C` to define code. Follow `BL` (Branch with Link) instructions to trace into `SystemInit` and `main` functions.
* **Step 2 (String Location)**: Open string window (Shift+F12). Clear source filenames (.c) and `irq` related strings should now be visible. Use cross-references (XREF) to locate key functions (USB drivers, audio decoders).
* **Step 3 (Interrupt Service)**: Return to vector table at `0x460`. While Reset is primary, subsequent 4-byte pointers correspond to NMI, HardFault, and external interrupts. Define these offsets as "Dword" and trace to find peripheral handling logic.

## 5. Known Pitfalls
* Do not analyze `0x000` - `0x460` region as code; it's metadata header only.
* Code may still contain unresolved data islands. If disassembly shows extensive errors, check if data tables (e.g., Jump Tables) are being misinterpreted as code.
"""

# Define absolute paths for input/output files
FILE_NAME = 'HIFIEC10.IMG'
OUTPUT_NAME = 'HIFIEC10_Fixed.bin'
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
INPUT_PATH = os.path.join(BASE_DIR, FILE_NAME)
OUTPUT_PATH = os.path.join(BASE_DIR, OUTPUT_NAME)

# Memory Map Constants derived from firmware analysis
# 0x000 - 0x460: Header (Little Endian, no swapping needed)
# 0x460 - 0x4A0: Vector Table (Little Endian, no swapping needed)
# 0x4A0 - End  : Code/Data Region (16-bit Swapped, requires repair)
HEADER_END = 0x460      # End of boot header region
VECTOR_END = 0x4A0      # End of vector table region

def swap_bytes_16bit(data):
    """
    Perform 16-bit byte swapping on data.
    
    Many embedded systems store code in swapped byte order (big-endian)
    while the processor expects little-endian. This swaps adjacent bytes
    within each 16-bit word.
    
    Example: AB CD -> BA DC
    
    Args:
        data (bytes): Input data with potential 16-bit swapped bytes
        
    Returns:
        bytes: Data with adjacent bytes swapped in 16-bit words
    """
    # Convert to bytearray for mutable operations
    arr = bytearray(data)
    
    # Ensure even length for 16-bit operations
    if len(arr) % 2 != 0:
        arr = arr[:-1]  # Drop last byte if odd length
    
    # Swap adjacent bytes: indices 0↔1, 2↔3, etc.
    arr[0::2], arr[1::2] = arr[1::2], arr[0::2]
    
    return bytes(arr)

def main():
    """
    Main execution function for firmware repair.
    
    Process flow:
    1. Read firmware image
    2. Separate into header, vector table, and code regions
    3. Apply 16-bit byte swapping to code region only
    4. Reassemble and write fixed firmware
    5. Perform verification checks
    """
    # Check if input file exists
    if not os.path.exists(INPUT_PATH):
        print(f"Error: Input file not found at {INPUT_PATH}")
        sys.exit(1)

    print(f"Processing: {INPUT_PATH}")
    
    # Read firmware image and separate into regions
    with open(INPUT_PATH, 'rb') as f:
        # 1. Read Header Region (0x000-0x460) - Keep original
        header_data = f.read(HEADER_END)
        
        # 2. Read Vector Table Region (0x460-0x4A0) - Keep original
        vector_data = f.read(VECTOR_END - HEADER_END)
        
        # 3. Read Code/Data Region (0x4A0-End) - Requires byte swapping
        body_data = f.read()

    # Display region sizes for verification
    print(f"Region 1 (Header) : {len(header_data)} bytes [Keep]")
    print(f"Region 2 (Vectors): {len(vector_data)} bytes [Keep]")
    print(f"Region 3 (Body)   : {len(body_data)} bytes [Swap]")

    # Apply 16-bit byte swapping to code/data region only
    fixed_body = swap_bytes_16bit(body_data)
    
    # Reassemble firmware with fixed code region
    final_data = header_data + vector_data + fixed_body
    
    # Write repaired firmware to output file
    with open(OUTPUT_PATH, 'wb') as f:
        f.write(final_data)
        
    print(f"Output Written    : {OUTPUT_PATH}")
    print("-" * 60)
    print("Verification Report:")

    # --- Verification Step 1: Entry Point Instruction ---
    # Reset Vector is stored at offset 0x4 within vector table (file offset 0x464)
    # Format: 32-bit little-endian value pointing to reset handler
    reset_vector_ptr = 0x464
    reset_vector_val = struct.unpack('<I', final_data[reset_vector_ptr:reset_vector_ptr+4])[0]
    
    # Calculate physical entry address (clear Thumb mode bit)
    # Cortex-M uses LSB=1 to indicate Thumb mode, but file offset calculation needs LSB=0
    entry_offset = reset_vector_val & ~1  # Clear LSB
    
    print(f"1. Entry Point Check")
    print(f"   Reset Vector   : 0x{reset_vector_val:08X}")
    print(f"   Physical Offset: 0x{entry_offset:08X}")
    
    # Verify entry point is within file bounds and contains valid instruction
    if entry_offset < len(final_data):
        # Read first 16-bit instruction at entry point
        snippet = final_data[entry_offset : entry_offset + 2]
        ins_val = struct.unpack('<H', snippet)[0]
        
        print(f"   Instruction    : 0x{ins_val:04X}")
        
        # 0x2B21 corresponds to CMP R3, #33 in ARM Thumb encoding
        if ins_val == 0x2B21:
            print("   Status         : PASS (Valid CMP instruction)")
        else:
            print("   Status         : FAIL (Unexpected instruction)")
    else:
        print("   Status         : FAIL (Entry point out of bounds)")

    # --- Verification Step 2: String Consistency ---
    # Check for known strings that should appear after byte swapping
    print(f"\n2. String Check")
    target_string = b'irq'  # Common interrupt-related string in firmware
    if target_string in fixed_body:
        print(f"   Target '{target_string.decode()}' : FOUND")
        print("   Status         : PASS")
    else:
        print(f"   Target '{target_string.decode()}' : NOT FOUND")
        print("   Status         : FAIL")

    # --- Verification Step 3: Code Structure Analysis ---
    # Check for ARM Thumb function prologues (PUSH {R4-R7, LR})
    # Machine Code: B5 F0 (Little-endian byte sequence: F0 B5)
    print(f"\n3. Code Structure Check")
    prologue_signature = b'\xF0\xB5'
    prologue_count = fixed_body.count(prologue_signature)
    print(f"   Prologue Count : {prologue_count}")
    
    # Heuristic: Valid firmware typically has many function prologues
    if prologue_count > 50:
        print("   Status         : PASS (High density of valid code)")
    else:
        print("   Status         : WARNING (Low code density, may indicate issues)")

if __name__ == "__main__":
    main()
